7.마이크로서비스 아키텍처 패턴
=========================
## ⭕레이어드 아키텍처
- 고전적인 가장 대중적 아키텍처
- 3계층으로 구성
  - 프레젠테이션 계층: 사용자 인터페이스, 클라이언트 요청 처리
  - 비즈니스 계층: 비즈니스 로직, 도메인 모델 처리
  - 데이터 계층: 데이터베이스 접근, 영속성 관리
- 단방향 의존성(상위 → 하위 계층으로만 의존)
- 비즈니스 로직 구현이 트랜잭션 스크립트, 액티브 레코드인 경우 적합한 아키텍처
- 비유연성: 계층 간 강한 결합으로 인해 요구사항 변경 시 여러 계층을 수정해야 하는 변화 대응의 어려움

### ◉ 레이어드 아키텍처의 다양한 변종(e.g 서비스 계층 추가)
레이어드 아키텍처에는 다양한 변종이 존재하며 그 중에 대표적인 것이 서비스 계층 추가된 구조이다.
- 서비스 계층: 비즈니스 로직을 캡슐화하고 외부에서 호출할 수 있는 API를 제공하는 계층
  - 프레젠테이션 계층과 비즈니스 계층 사이에 위치하여 두 계층 간의 의존성을 줄이고 비즈니스 로직을 재사용 가능하게 한다.
  - 서비스 계층은 도메인 모델을 사용하여 비즈니스 로직을 구현하고 데이터베이스 접근은 리포지토리 패턴을 통해 처리한다.

<img src="../resources/images/레이어드 아키텍처(서비스 계층 추가).png" alt="레이어드 아키텍처(서비스 계층 추가)" style="width: 100%; height: auto;" />

### ◉ 레이어드 아키텍처 리팩토링 - DIP(의존 관계 역전) 적용
상위 계층이 하위 계층 구현체에 직접 의존하여 발생하는 강한 결합과 테스트 어려움을 해결하기 위해 등장
- 기존 구조: Service → Repository(구현체) → Database (하위 계층 구현에 직접 의존)
- DIP 적용: Service → Repository(인터페이스) ← Repository구현체 → Database (추상화에 의존)
- 장점: 테스트 용이성 향상, 기술 변경 유연성 확보, 비즈니스 로직과 데이터 접근 기술 분리

```kotlin
// AS-IS
class UserService {
    private val userRepository = MySQLUserRepository() // 구체 클래스에 의존
}

// TO-BE
// 인터페이스 정의
interface UserRepository {
    fun findById(id: Long): User
}

// Service는 인터페이스에만 의존
class UserService(private val userRepository: UserRepository)

// 구현체가 인터페이스를 구현
class MySQLUserRepository : UserRepository
```

## ⭕헥사고날 & 클린 아키텍처
### ◉ 헥사고날 아키텍처
포트와 어댑터 패턴이라고도 불리며 애플리케이션을 중심에 두고 외부 의존성들을 어댑터를 통해 연결하는 아키텍처 패턴

#### ✦ 헥사고날 아키텍처의 구성 요소
- 도메인 코어: 비즈니스 로직과 도메인 모델을 포함하는 핵심 부분
- 포트: 도메인 코어와 외부 시스템 간의 인터페이스를 정의하는 부분
  - 인바운드 포트: 도메인 코어가 외부 시스템으로부터 요청을 받는 인터페이스 (UseCase 인터페이스)
  - 아웃바운드 포트: 도메인 코어가 외부 시스템에 요청을 보내는 인터페이스 (Repository 인터페이스)
- 어댑터: 포트를 구현하여 외부 시스템과 도메인 코어를 연결하는 부분
  - 인바운드 어댑터: 외부 시스템의 요청을 도메인 코어로 전달하는 역할 (웹 컨트롤러, CLI 등)
  - 아웃바운드 어댑터: 도메인 코어의 요청을 외부 시스템으로 전달하는 역할 (데이터 베이스, 외부 API 등)

<img src="../resources/images/헥사고날 아키텍처.png" alt="헥사고날 아키텍처" style="width: 100%; height: auto;" />

##### 장점
- 도메인 로직이 외부 기술에 독립적
- 테스트 용이성 (포트를 Mock으로 대체 가능)
- 유연성 (어댑터 교체로 기술 변경 쉬움)
- 명확한 책임 분리

##### 단점
- 초기 구현 복잡도 증가
- 작은 프로젝트에는 과도할 수 있음
- 인터페이스 수 증가

##### 사용 케이스
- 외부 시스템 의존성이 많은 경우
- 기술 변경이 빈번한 경우
- 도메인 로직이 복잡한 경우
- 테스트 커버리지가 중요한 경우

#### ✦ 헥사고날 아키텍처로 도입한 마이크로 서비스
<img src="../resources/images/헥사고날 마이크로 서비스 아키텍처.png" alt="헥사고날 마이크로 서비스 아키텍처" style="width: 100%; height: auto;" />

### ◉ 클린 아키텍처
의존성 규칙을 통해 비즈니스 로직을 외부 관심사로부터 독립시키는 계층형 아키텍처 패턴

#### ✦ 클린 아키텍처의 구성 요소
- 프레임워크와 드라이버: 외부 도구들 (웹, DB, 외부 인터페이스)
- 인터페이스 아답터: 유스케이스/엔티티와 외부 계층 간 데이터 변환을 담당하는 어댑터 집합으로 Controllers, Presenters, Gateways 포함
- 유스 케이스: 애플리케이션 특화 비즈니스 규칙을 포함하며 엔티티에 영향을 주지 않고 외부 요소에 영향받지 않는 애플리케이션 워크플로우
- 엔티티: 도메인 모델과 비즈니스 규칙을 포함하는 계층

<img src="../resources/images/클린 아키텍처.png" alt="클린 아키텍처" style="width: 100%; height: auto;" />

##### 장점
- 비즈니스 로직이 프레임워크에 독립적
- 의존성 방향이 명확하여 테스트 용이
- 외부 변경에 대한 영향 최소화
- 유지보수성과 확장성 향상

##### 단점
- 높은 초기 복잡도와 많은 추상화 레이어
- 작은 프로젝트에는 과도한 구조
- 학습 곡선이 가파름
- 개발 속도 초기 저하

##### 사용 케이스
- 복잡한 비즈니스 로직이 있는 대규모 엔터프라이즈 시스템
- 장기간 유지보수가 필요한 프로젝트
- 외부 의존성 변경이 빈번한 환경
- 높은 테스트 커버리지가 요구되는 시스템

## ⭕CQRS (Command Query Responsibility Segregation)
명령(Command)과 조회(Query)의 책임을 분리하는 아키텍처 패턴으로 데이터를 변경하는 작업과 데이터를 읽는 작업을 서로 다른 모델로 처리
- 커맨드 실행 모델: 데이터 변경을 담당, 비지니스 로직을 구현하고 강력한 일광성을 보장하는 도메인 중심 모델
- 쿼리 모델: 데이터 조회를 담당, 읽기 최적화된 모델로 성능과 확장성을 고려하여 설계
  - 인 메모리 캐시: Redis, Memcached 등
  - 일반 파일: JSON, CSV 등
  - Materialized View: 데이터베이스에 최적화된 형태로 저장
  - 데이터베이스: NoSQL, RDBMS 등
- 동기화 메커니즘: 커맨드와 쿼리 모델 간의 데이터 일관성을 유지하기 위한 메커니즘
  - 동기식: 커맨드 실행 후 쿼리 모델을 즉시 업데이트
  - 비동기식: 이벤트 소싱, 메시지 큐 등을 사용하여 커맨드 실행 후 쿼리 모델을 업데이트
- 확장성과 기능
  - 읽기 성능 최적화: 쿼리 모델을 읽기 전용으로 최적화하여 높은 성능 제공
  - 다양한 저장소: Command(PostgreSQL, MySQL 등)와 Query(Elasticsearch, Redis 등) 저장소를 분리하여 최적화된 데이터 저장
  - 독립적 확장: 커맨드와 쿼리 모델을 독립적으로 스케일링 가능

##### 장점
읽기와 쓰기를 각각 최적화하여 전체 성능 향상
복잡한 리포팅 쿼리와 비즈니스 로직 완전 분리
각 모델에 최적화된 다양한 저장 기술 활용
독립적인 확장과 배포 가능

##### 단점
- 두 개의 모델 관리로 인한 복잡도 증가
- 동기화 지연으로 인한 최종 일관성 문제
- 초기 구현과 인프라 구축 비용 증가
- 데이터 중복과 동기화 로직의 복잡성

##### 사용 케이스
- 읽기 요청이 쓰기 요청보다 10배 이상 많은 시스템
- 복잡한 대시보드와 분석 리포팅이 필요한 비즈니스 시스템
- 높은 가용성과 성능이 중요한 대규모 e-커머스 플랫폼
- 실시간 모니터링과 다양한 뷰가 필요한 IoT 시스템

## ⭕아키텍처 패턴 선택 방법
- 레이어드 아키텍처 (3계층)
  - 단순한 CRUD 애플리케이션, 비즈니스 로직이 복잡하지 않은 경우
  - 비즈니스 로직 패턴: 트랜잭션 스크립트, 액티브 레코드
  - 특징: 프레젠테이션 → 비즈니스 → 데이터 계층의 단순한 구조 
- 레이어드 아키텍처 (4계층: 서비스 계층 추가)
  - 3계층과 동일하지만 비즈니스 로직 캡슐화와 재사용성 향상이 필요한 경우
  - 비즈니스 로직 패턴: 트랜잭션 스크립트, 액티브 레코드
  - 특징: 프레젠테이션 → 서비스 → 비즈니스 → 데이터 계층
- 헥사고날 아키텍처
  - 적용 케이스: 복잡한 비즈니스 로직, 외부 시스템 의존성이 많은 경우, 테스트 용이성이 중요한 경우 
  - 비즈니스 로직 패턴: 도메인 모델, 애그리거트 패턴 
  - 특징: 포트와 어댑터를 통한 도메인 중심 설계
- 클린 아키텍처
  - 장기간 유지보수가 필요한 복잡한 엔터프라이즈 시스템, 프레임워크 독립성이 중요한 경우 
  - 비즈니스 로직 패턴: 도메인 모델, 애그리거트 패턴 
  - 특징: 의존성 규칙을 통한 계층형 구조, 엔티티 → 유스케이스 → 인터페이스 어댑터 → 프레임워크
- CQRS
  - 읽기와 쓰기 비율이 크게 다른 시스템, 복잡한 조회와 리포팅이 필요한 경우, 높은 성능과 확장성이 요구되는 대규모 시스템 
  - 비즈니스 로직 패턴: 모든 패턴과 조합 가능 (주로 도메인 모델과 함께 사용)
  - 특징: 명령과 조회의 완전한 분리, 각각 최적화된 모델 사용

### ◉ 선택 기준
- 프로젝트 복잡도: 단순함 → 복잡함 순으로 레이어드 → 헥사고날/클린 → CQRS
- 팀 경험: 아키텍처 패턴에 대한 팀의 이해도와 경험
- 비즈니스 요구사항: 성능, 확장성, 유지보수성의 우선순위
- 기술적 제약사항: 기존 시스템과의 호환성, 인프라 환경

## ⭕MSA 커뮤니케이션 유형
- 동기 방식: 서비스 간의 직접적인 호출로 요청-응답 패턴을 따르는 방식
  - HTTP/REST: RESTful API를 사용하여 서비스 간 통신
  - gRPC: 구글의 RPC 프레임워크로, 프로토콜 버퍼를 사용하여 효율적인 바이너리 통신
  - GraphQL: 클라이언트가 필요한 데이터만 요청할 수 있는 쿼리 언어
- 비동기 방식: 요청 후 응답을 기다리지 않고 다른 작업을 계속하는 통신 방식
  - 메시지 브로커: 메시지를 중개하여 서비스 간의 비동기 통신을 지원
    - 메시지 큐: 큐에 메시지를 저장하고 순차적으로 처리, 주로 일대일 통신 (RabbitMQ, Apache ActiveMQ, Amazon SQS)
    - 이벤트 스트리밍: 이벤트를 연속적으로 발행하고 여러 서비스가 구독하여 처리 (Apache Kafka, AWS Kinesis, Azure Event Hubs)
  - 이벤트 기반 통신: 도메인 이벤트 발행/구독을 통한 서비스 간 통신
    - 이벤트 버스: 경량화된 이벤트 발행/구독 시스템으로 서비스 간 느슨한 결합 지원 (Redis Pub/Sub, Apache Pulsar, Google Cloud Pub/Sub)
    - 경량 이벤트 시스템: 애플리케이션 내부 또는 간단한 서비스 간 이벤트 처리 (EventEmitter(Node.js), Spring Events)
- 상태 기반 방식: 서비스가 클라이언트나 세션의 상태 정보를 관리하는지에 따른 통신 방식
  - 무상태(Stateless): 서비스가 클라이언트 상태를 기억하지 않는 방식
    - API Gateway: 단일 진입점 제공, 라우팅과 인증만 담당 (Kong, AWS API Gateway)
    - 프록시: 요청을 단순 전달 (Nginx, HAProxy)
    - 로드 밸런서: 트래픽 분산 (AWS ALB, F5)
  - 상태 유지(Stateful): 서비스가 클라이언트별 상태나 세션을 유지하는 방식
    - BFF(Backend for Frontend): 특정 클라이언트에 최적화된 API 제공
    - 세션 기반 프록시: 사용자별 개인화 정보 유지 (프록시 + Redis/DB)
    - 스티키 세션: 특정 서버에 클라이언트 고정
- 통합 패턴 방식: 서로 다른 서비스나 시스템 간 데이터 형식과 프로토콜을 맞추는 통신 방식
  - 공표된 언어(PL, Published Language): 모든 서비스가 공통된 데이터 형식을 사용하여 통신 (JSON 스키마, Protocol Buffer, OpenAPI 스펙)
  - 부패 방지 계층(ACL, Anti-Corruption Layer): 외부 시스템의 데이터를 내부 모델로 변환하여 내부 도메인을 보호 (레거시 시스템 연동 시 변환 레이어, 외부 API 래퍼)

## ⭕ EDA 고려사항
### ◉ 이벤트 드리븐 아키텍처 (EDA, Event-Driven Architecture)
이벤트의 생성, 감지, 소비, 반응을 중심으로 설계된 소프트웨어 아키텍처 패턴

#### ✦ EDA의 구성 요소
- 이벤트: 시스템에서 발생한 중요한 상태 변경이나 동작을 나타내는 메시지
  - 이벤트는 불변이며, 과거형으로 표현되고 발생 시점과 관련된 데이터를 포함
- 이벤트 프로듀서: 이벤트를 생성하고 발행하는 주체
  - 도메인 이벤트, 시스템 이벤트 등 다양한 유형의 이벤트를 생성
- 이벤트 컨슈머: 이벤트를 구독하고 처리하는 주체
  - 이벤트를 수신하여 비즈니스 로직을 실행하거나 다른 시스템과 통합
- 이벤트 채널/브로커: 이벤트를 전달하는 중개 역할을 하는 시스템
  - 이벤트를 발행하고 구독하는 프로듀서와 컨슈머 간의 통신을 관리
  - 예: Apache Kafka, RabbitMQ, AWS EventBridge, AWS SNS/SQS 등

#### ✦ EDA의 주요 특징
- 비동기성: 이벤트 프로듀서는 이벤트 발행 후 응답을 기다리지 않고 다른 작업 수행
- 느슨한 결합: 이벤트 프로듀서와 컨슈머 간의 직접적인 의존성이 없어 시스템의 유연성과 확장성을 높임
- 확장성: 새로운 이벤트 컨슈머를 추가하거나 기존 컨슈머를 확장하는 것이 용이
- 실시간 처리: 이벤트 발생 시 실시간으로 반응하여 데이터 처리와 분석이 가능

#### ✦ EDA의 장점
- 유연성: 새로운 이벤트 컨슈머를 추가하거나 기존 시스템을 변경하는 것이 용이
- 확장성: 이벤트 프로듀서와 컨슈머를 독립적으로 확장할 수 있음
- 실시간 반응: 이벤트 발생 시 즉시 반응할 수 있어 실시간 처리가 가능
- 느슨한 결합: 서비스 간 직접적인 의존성이 없어 시스템 유연성 향상
- 장애 격리: 한 서비스의 장애가 다른 서비스에 직접적인 영향을 주지 않음

#### ✦ EDA의 단점
- 복잡성: 이벤트 흐름 추적과 관리를 위한 추가적인 복잡성 발생
- 디버깅 어려움: 분산된 비동기 이벤트 처리로 인해 문제 발생 시 디버깅이 어려움
- 최종 일관성: 강한 일관성 대신 최종 일관성만 보장되어 일시적 데이터 불일치 가능
- 이벤트 순서: 이벤트 처리 순서 보장의 어려움
- 모니터링 복잡성: 분산된 이벤트 흐름을 모니터링하고 추적하는 것이 복잡

### ◉ EDA 적용 시 고려사항
#### ✦ 장애 상황과 데이터 소실 처리 
- 네트워크, 서버 장애로 인한 데이터 소실 
- 이벤트 순서 꼬임 
- 이벤트 중복 처리

##### 해결 방안
- 메시지 전달 보장 (동기 전송, ACK 모드)
- 메시지 영구 저장 및 지속성 (퍼시스턴트 큐)
- 실패 처리 메커니즘 (재시도, DLQ)
- 중복 및 순서 보장 (멱등성, 순서 보장)
- 트랜잭션 완료 보장 (LPS - Last Participant Support)
- 데이터 일관성 보장 (ACID 트랜잭션)

#### ✦ 트랜잭션 일관성 문제
데이터 처리와 이벤트 발행을 하나의 트랜잭션으로 묶어도 발행된 이벤트가 전달되지 않으면 일관성이 깨짐

##### 해결 방안: 아웃박스 패턴
- 로컬 트랜잭션으로 비즈니스 데이터와 이벤트를 함께 저장
- 별도 프로세스가 아웃박스 테이블을 폴링하여 이벤트 발행
- At-least-once 보장으로 이벤트 전달 확실히 처리

<img src="../resources/images/아웃박스 패턴.png" alt="아웃박스 패턴" style="width: 100%; height: auto;" />

#### ✦ 분산 트랜잭션 일관성 문제
여러 마이크로서비스에 걸친 장기간 비즈니스 프로세스에서 일관성 보장 어려움

##### 해결 방안
- 사가 패턴: 여러 트랜잭션을 순차적으로 실행 
- 보상 트랜잭션: 각 단계별로 롤백 가능한 보상 액션 정의 
- 실패 시 역순 실행: 보상 트랜잭션을 통해 데이터 일관성 유지

<img src="../resources/images/사가 패턴.png" alt="사가 패턴" style="width: 100%; height: auto;" />
