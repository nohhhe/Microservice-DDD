10.설계 의사 결정 및 구현과정 소개
=========================
### ◉ 휴리스틱
- 휴리스틱이란 문제를 해결하거나 의사 결정을 내리기 위해 사용하는 경험적 규칙이나 직관적인 방법

#### ✦ 바운디드 컨텍스트
- 크기로 경계를 구분하지 않는다. 
- 바운디드 컨텍스트를 식별할 때는 경계를 넓게 해서 시작하자.
- 나중에 도메인 지식이 쌓이게 되면 좀 더 작은 경계로 쪼갠다.

### ◉ 비지니스 로직 구현 패턴 과 아키텍처 패턴 결정
- Biz Logic 간단함 -> 지원, 일반 -> Transaction Script, Active Record
  - 단순한 자료 구조 -> Transaction Script
  - 복잡한 자료구조 -> Active Record
- Biz Logic 복잡 -> 핵심 -> Domain Model
  - 금전 또는 통화의 트랜잭션 추적, 일관된 감사 로그 , 동작에 따른 심층적 분석 요구 -> Event Sourcing

<img src="../resources/images/비지니스 로직 구현 패턴 과 아키텍처 패턴 결정.png" alt="비지니스 로직 구현 패턴 과 아키텍처 패턴 결정" style="width: 100%; height: auto;" />

### ◉ 테스트 전략의 결정
#### ✦ 피라미드형 테스트 - 단위 테스트를 가장 많이, E2E 테스트를 가장 적게 작성하는 테스트 전략
- 고전적인 전략
- 도메인 모델 패턴

<img src="../resources/images/피라미드형 테스트.png" alt="피라미드형 테스트" style="width: 100%; height: auto;" />

#### ❓왜 단위 테스트를 중점적으로 하는지?
1. 빠른 실행 속도 - 몇 초 안에 수천 개 테스트 실행 가능
2. 저렴한 비용 - 외부 의존성(DB, API) 없이 독립 실행
3. 명확한 문제 파악 - 실패 시 정확히 어느 코드가 문제인지 즉시 확인
4. 높은 안정성 - 외부 요인(네트워크, 환경)에 영향받지 않음

#### ❓왜 도메인 모델 패턴에서 많이 사용하는지?
1. 비즈니스 로직이 순수 객체에 집중 - 도메인 모델 패턴은 핵심 비즈니스 로직을 도메인 엔티티/밸류 객체에 담음. 이 객체들은 DB, API 등 외부 의존성이 없는 순수한 객체라서 단위 테스트만으로 충분히 검증 가능.
2. 빠르고 쉬운 단위 테스트 작성 - 도메인 객체는 외부 의존성이 없어서 Mock 없이도 즉시 인스턴스를 생성하고 테스트 가능. 서비스 계층은 Mock을 쓰지만, 핵심 로직이 도메인에 있어서 대부분의 테스트가 빠른 단위 테스트로 가능.
3. 복잡한 비즈니스 규칙의 다양한 케이스 검증 - 도메인 모델에는 복잡한 비즈니스 규칙이 많은데, 이를 수백 개의 단위 테스트로 빠르게 검증 가능해서 피라미드 하단을 두껍게 만들 수 있음.
4. 통합 테스트는 최소화 - 실제 DB 연동 등은 리포지토리 계층에서만 필요하므로, 통합/E2E 테스트는 최소한만 작성하면 됨.

#### ✦ 다이아몬드형 테스트 - 통합 테스트를 가장 많이 작성하는 테스트 전략
- 통합 테스트에 집중
- 액티브 레코드 패턴

<img src="../resources/images/다이아몬드형 테스트.png" alt="다이아몬드형 테스트" style="width: 100%; height: auto;" />

#### ❓왜 통합 테스트를 중점적으로 하는지?
1. 실제 동작 검증 - DB, ORM, 프레임워크 등이 실제로 함께 동작하는 것을 확인 가능
2. 리팩토링 안전성 - 내부 구현이 바뀌어도 테스트가 깨지지 않음 (인터페이스 중심 테스트)
3. 현실적인 시나리오 - 실제 사용자 관점에서 기능이 제대로 작동하는지 검증
4. 단위 테스트의 한계 극복 - Mock으로 가려진 실제 통합 문제를 발견 가능

#### ❓왜 액티브 레코드 패턴에서 많이 사용하는지?
1. 비즈니스 로직이 여러 계층에 분산 - 액티브 레코드는 DB 접근 로직과 비즈니스 로직이 엔티티에 함께 있어서, 단위 테스트만으로는 검증이 어려움.
2. DB 의존성이 높음 - 엔티티 자체가 DB 테이블과 1:1 매핑되고 ORM 기능을 포함하므로, 실제 DB 없이는 의미있는 테스트가 불가능.
3. Mock의 한계 - DB 연결, 트랜잭션, 쿼리 최적화 등 실제 환경에서만 발생하는 문제를 통합 테스트로 발견 가능.

#### ✦ 역전된 피라미드형 테스트 - E2E 테스트를 가장 많이 작성하는 테스트 전략
- End To End 테스트에 집중
- 트랜잭션 스크립트 패턴

<img src="../resources/images/역전된 피라미드형 테스트.png" alt="역전된 피라미드형 테스트" style="width: 100%; height: auto;" />

#### ❓왜 E2E 테스트를 중점적으로 하는지?
1. 로직이 여러 곳에 분산 - 비즈니스 로직이 컨트롤러, 서비스, SQL, DB 프로시저 등 여러 곳에 흩어져 있어서, 각 부분만 따로 테스트하면 의미가 없음. 전체를 함께 실행해야 제대로 동작하는지 확인 가능.
2. 단위 테스트 작성 어려움 - 순수한 비즈니스 로직을 담은 객체가 없고, 모든 메소드가 DB나 외부 시스템에 강하게 결합되어 있어서 격리해서 테스트할 수 없음.
3. 통합된 상태만 신뢰 - 각 부분이 따로 동작하는 것보다, 실제 API 호출부터 DB 저장까지 전체 흐름이 연결됐을 때만 신뢰할 수 있다고 판단.
4. 레거시 시스템 - 테스트 없이 개발된 오래된 시스템에 나중에 테스트를 추가할 때, 구조 개선 없이 E2E부터 시작하는 경우.

#### ❓왜 트랜잭션 스크립트 패턴에서 많이 사용하는지?
1. 비즈니스 로직이 프로시저처럼 분산 - "회원가입 처리", "주문 처리" 같은 트랜잭션마다 메소드를 만들고, 그 안에서 validation → 조회 → 계산 → 저장을 순차적으로 처리. 로직이 한 메소드에 길게 나열되거나 컨트롤러, SQL, 프로시저 등에 흩어짐.
2. 도메인 객체 부재 - 데이터만 담는 DTO만 있고, 비즈니스 규칙을 담은 도메인 객체가 없어서 단위 테스트로 검증할 로직 자체가 없음.
3. 강한 DB 결합 - 서비스 메소드가 직접 SQL 쿼리를 실행하거나 DB 프로시저를 호출해서, 실제 DB 없이는 테스트 자체가 불가능함.
4. 중복 로직과 복잡도 증가 - 같은 계산 로직이 여러 트랜잭션 스크립트에 중복되고 서로 얽혀있어서, 결국 전체 시나리오를 E2E로 테스트할 수밖에 없음.

#### ❗️문제점
- 느린 실행 속도 (수십 분~수 시간)
- 불안정한 테스트 (네트워크, 환경 문제로 자주 실패)
- 높은 유지보수 비용
- 실패 시 원인 파악 어려움


#### ✦
| 항목 | 내용 |
|----|----|
|  |    |
|  |    |
|  |    |
|  |    |
|  |    |

#### ❓
* a
* b
* c
#### ❗️
