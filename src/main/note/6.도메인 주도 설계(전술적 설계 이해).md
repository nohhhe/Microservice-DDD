6.도메인 주도 설계(전술적 설계 이해)
=========================
## ⭕트랜잭션 스크립트 패턴
트랜잭션 스크립트 패턴은 간단한 비즈니스 로직을 구현할 때 사용되는 패턴으로 주로 단순한 CRUD 작업에 적합하다.
이 패턴은 비즈니스 로직을 단일 프로시저나 메소드로 구현하여 데이터베이스 트랜잭션을 관리한다.
- 간단한 비지니스 로직 구현의 경우
- 절차 지향 스크립트로 구현, 데이터 베이스 직접 접근도 가능
- 각 작업은 성공하거나 실패할 수 있지만 유효하지 않는 상태로 만들면 안된다 
- 단순한 지원 하위 도메인, 연동 어댑터, 충돌 방지 계층
- 비즈니스 로직이 복잡할수록 트랜잭션간 비즈니즈 로직이 중복되기 쉽고 결과적으로 중복된 코드가 동기화 되지 않으면 일관성 없는 동작이 발생됨
-> 유지보수가 불가능한 거대한 진흙 덩어리가 될 가능성 높음
- 핵심 하위 도메인에는 사용하지 않는 것이 좋다.

<img src="../resources/images/트랜잭션 스크립트 패턴.png" alt="트랜잭션 스크립트 패턴" style="width: 100%; height: auto;" />

### ◉ 장점
- 이해하기 쉽고 구현이 간단 
- 작은 프로젝트에 적합 
- 디버깅이 용이

### ◉ 단점
- 복잡한 비즈니스 로직에는 부적합
- 코드 재사용이 어려움
- 유지보수가 힘들어질 수 있음

### ◉ 예제
```text
주문 처리 스크립트() {
  1. 사용자 정보 확인
  2. 상품 재고 확인  
  3. 재고 차감
  4. 주문 생성
  5. 결제 처리
  6. 배송 정보 등록
  
  // 중간에 실패하면 모든 작업 롤백
}
```

## ⭕액티브 레코드 패턴
액티브 레코드 패턴은 객체 지향 프로그래밍에서 데이터베이스의 테이블을 객체로 매핑하여 CRUD 작업을 수행하는 패턴이다.
- 비지니스 로직이 단순한 경우
- Active Record 라는 전용 객체를 사용하여 복잡한 자료 구조를 표현, 자료 구조 외에도 CRUD 구현,ORM 연계
- 즉 Active Record 는 데이터 접근 로직 구현
- Entity 에 약간의 비즈 로직 포함 가능하지만 대부분의 비지니스로직 및 흐름은 응용서비스의 행위에 의해 처리됨
- Anemic Domain Model (빈약한 도메인 모델)
- 본질적으로는 데이터베이스 접근을 최적화하는 Transaction Script 패턴의 유형
- 모델에 있는 로직은 사용자 입력의 유효성을 검사하는 CRUD작업과 같은 비교적 간단한 비즈로직
- 지원 하위 도메인, 일반 하위 도메인에 적합
- 비즈 로직은 단순하지만 복잡한 자료 구조인 경우

<img src="../resources/images/액티브 레코드 패턴.png" alt="액티브 레코드 패턴" style="width: 100%; height: auto;" />

### ◉ 장점
- 구현이 직관적이고 이해하기 쉬움
- 빠른 개발과 프로토타입 제작에 적합
- 단순한 CRUD 작업에 효율적
- ORM 프레임워크 지원으로 개발 생산성 향상
- 데이터와 행위가 한 곳에 모여 있어 응집도가 높음

### ◉ 단점
- 복잡한 비즈니스 로직 구현에 부적합
- 데이터베이스 스키마 변경 시 영향 범위가 큼
- 테스트가 어려움 (데이터베이스 의존성)
- 빈약한 도메인 모델이 되기 쉬움
- 대규모 시스템에서 유지보수 어려움

### ◉ 예제
``` kotlin
class Order {
    var customerId: Long = 0
    var productId: Long = 0
    var amount: Double = 0.0
    
    fun save() {
        // 데이터베이스에 저장 로직
    }
}

class CreateOrder {
    fun execute(orderDetails: OrderDetails) {
        try {
            db.startTransaction()
            
            val order = Order()
            order.customerId = orderDetails.customerId
            order.productId = orderDetails.productId
            order.amount = orderDetails.amount
            order.save()
            
            db.commit()
        } catch (e: Exception) {
            db.rollback()
            throw e
        }
    }
}
```

## ⭕도메인 모델 패턴
도메인 모델 패턴은 비즈니스 도메인을 객체로 모델링하여 복잡한 비즈니스 로직을 표현하는 패턴이다.
- 도메인 모델은 행위 + 자료구조를 통해 비지니스 로직 구현
- POJO로 구성 : 이미 본질적으로 복잡하므로 인프라, 기술적 관심사를 피해야 함
- 응용서비스에서는 대부분 업무 흐름 제어만 하며 주요 비지니스 로직은 도메인 모델에 위임하여 처리

<img src="../resources/images/도메인 모델 패턴.png" alt="도메인 모델 패턴" style="width: 100%; height: auto;" />

### ◉ 장점
- 복잡한 비즈니스 로직을 객체지향적으로 표현 가능 
- 도메인 지식이 코드에 명확히 표현되어 유지보수성 향상 
- 단위 테스트 작성이 용이함 (인프라 의존성 최소화)

### ◉ 단점
- 초기 설계 비용이 높음 (도메인 분석 및 모델링 필요)
- 단순한 CRUD 작업에는 과도한 복잡성 초래
- 개발자의 높은 객체지향 설계 역량 요구

### ◉ 도메인 주도 설계의 애그리거트 패턴
- 도메인 모델 패턴 적용 시 도메인 모델이 점점 복잡하고 비대해짐
- 이에 그 복잡성을 관리할 단위를 구분해 냄 (도메인 주도의 Aggregate)
- 대부분 한개의 Entity와 여러개의 VO구성

<img src="../resources/images/도메인%20주도%20설계의%20애그리거트%20패턴.png" alt="도메인 주도 설계의 애그리거트 패턴" style="width: 100%; height: auto;" />

#### ✦ 장점
- 도메인 모델의 복잡성을 논리적 단위로 분할하여 관리
- 트랜잭션 일관성 경계를 명확히 정의
- 애그리거트 루트를 통한 접근으로 무결성 보장

#### ✦ 단점
- 애그리거트 경계 설정이 어려워 잘못 나누면 성능 저하
- 애그리거트 간 참조 제약으로 구현 복잡도 증가
- 초기 설계 시 높은 도메인 지식과 경험 필요

#### ✦ 애그리거트 패턴 구성요소 - Value Object
Value Object(VO)는 식별자가 없고 값 자체로 동등성을 판단하는 불변 객체입니다.
- 식별자: 값 자체가 중요
- 불변성: 생성 후 변경 불가
- 값 동등성: 모든 속성 값이 같으면 동일한 객체
- DTO와 헷갈리지 말 것 DTO는 프레젠테이션 계층과 도메인 계층에서 사용되는 구조체 개념

##### 예제
```kotlin
data class Money(
    val amount: BigDecimal,
    val currency: String = "KRW"
)

data class Address(
    val zipCode: String,
    val city: String,
    val street: String
)

val price = Money(BigDecimal("10000"))
val address = Address("12345", "서울시", "강남대로")
```

#### ✦ 애그리거트 패턴 구성요소 - Entity
Entity는 고유한 식별자를 가지며 생명주기 동안 상태가 변할 수 있는 가변 객체입니다.
- 모든 도메인의 필수 구성요소
- 도메인의 고유 개념 표현
- 상태 변경 가능 (가변성)
- 자신의 생명주기와 행위를 가짐
- 다른 객체와 구별할 수 있는 식별자(고유 식별자)를 갖는 객체
- DB Entity와의 차이: 데이터와 함께 기능(행위)을 제공

##### 예제
```kotlin
class Product(
    val id: Long,
    var name: String,
    var price: Money
) {
    fun changePrice(newPrice: Money) {
        this.price = newPrice
    }
}

// 사용 예제
val product = Product(1L, "노트북", Money(BigDecimal("1500000")))
product.changePrice(Money(BigDecimal("1400000"))) // 상태 변경 가능

// 동등성 비교 - ID로만 판단
val product1 = Product(1L, "노트북", Money(BigDecimal("1500000")))
val product2 = Product(1L, "맥북", Money(BigDecimal("2000000")))
```

<img src="../resources/images/도메인 모델 예시.png" alt="도메인 모델 예시" style="width: 100%; height: auto;" />

#### ✦ 애그리거트
애그리거트는 도메인 모델의 복잡성을 관리하기 위해 관련된 Entity와 Value Object를 그룹화한 단위이다.
- 관련 객체를 하나로 묶은 군집
- Aggregate는 Entity, 목적은 데이터 일관성을 보호, 데이터 변경 시 Aggregate 단위로 처리
- Aggregate Root를 통해 Aggregate 내의 다른 Entity 및 VO 접근
- 데이터 변경의 단위, 트랜잭션 단위가 되는 연관된 객체 묶음

<img src="../resources/images/Aggregate.png" alt="Aggregate" style="width: 100%; height: auto;" />

##### 설계 고려사항
- 하나의 Transaction에서는 하나의 Aggregate만 수정함
- Transaction 일관성과 성공을 보장하도록 Aggregate 구성요소들을 설계해야 함
- 하나의 일을 잘 수행할 수 있도록 작게 설계해야함
- 작게 설계할 수록 성능이 좋고 확장에 용이함, 변경사항 Commit할 때 문제도 거의 발생되지 않음
- 한 Aggregate 에서 다른 Aggregate 의 참조는 식별자를 통해서만 참조해야 함
- 하나의 Transaction 내에서 여러 개의 Aggregate 이 수정되는 것을 방지할 수 있음
- 하나의 Transaction에서 여러 개의 Aggregate이 갱신되어야 하는 경우 다른 Aggregate 의 갱신은 비동기 통신을 활용해서 결과적 일관성을 맞춰야 함

##### ❓결과적 일관성
일관성을 유지시켜야 하는 데이터가 일정시간 다른 데이터와 일치 하지 않을 수도 있지만 어느 시점이 되면 결국 일치하게 된다.

<img src="../resources/images/Aggregate 식별자 참조.png" alt="Aggregate 식별자 참조" style="width: 100%; height: auto;" />

##### 특징
- 각 Aggregate은 일관성 있는 Transaction 경계를 형성함
- 즉, Transaction 제어가 DB에 Commit 될 때 한 Aggregate 내의 모든 구성요소들은 비즈니스 규칙을 따르면서 일관성 있게 처리되어야 함

##### 문제점
- 시간이 지날수록 하위의 객체의 인스턴스의 증가가 결국 엄청난 크기로 불어날 수 있음
- 따라서 하나의 일을 잘 수행할 수 있는 작은 Aggregate로 분리해야함
