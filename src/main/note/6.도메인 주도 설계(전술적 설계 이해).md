6.도메인 주도 설계(전술적 설계 이해)
=========================
## ⭕비즈니스 로직 구현 패턴
- 트랜잭션 스크립트 패턴
- 액티브 레코드 패턴
- 도메인 모델 패턴
- 애그리거트 패턴
- 이벤트 소싱 모델

## ⭕ 트랜잭션 스크립트 패턴
트랜잭션 스크립트 패턴은 간단한 비즈니스 로직을 구현할 때 사용되는 패턴으로 주로 단순한 CRUD 작업에 적합하다.
이 패턴은 비즈니스 로직을 단일 프로시저나 메소드로 구현하여 데이터베이스 트랜잭션을 관리한다.
- 간단한 비지니스 로직 구현의 경우
- 절차 지향 스크립트로 구현, 데이터 베이스 직접 접근도 가능
- 각 작업은 성공하거나 실패할 수 있지만 유효하지 않는 상태로 만들면 안된다 
- 단순한 지원 하위 도메인, 연동 어댑터, 충돌 방지 계층
- 비즈니스 로직이 복잡할수록 트랜잭션간 비즈니즈 로직이 중복되기 쉽고 결과적으로 중복된 코드가 동기화 되지 않으면 일관성 없는 동작이 발생됨
-> 유지보수가 불가능한 거대한 진흙 덩어리가 될 가능성 높음
- 핵심 하위 도메인에는 사용하지 않는 것이 좋다.

<img src="../resources/images/트랜잭션 스크립트 패턴.png" alt="트랜잭션 스크립트 패턴" style="width: 100%; height: auto;" />

### ◉ 장점
- 이해하기 쉽고 구현이 간단 
- 작은 프로젝트에 적합 
- 디버깅이 용이

### ◉ 단점
- 복잡한 비즈니스 로직에는 부적합
- 코드 재사용이 어려움
- 유지보수가 힘들어질 수 있음

### ◉ 예제
```text
주문 처리 스크립트() {
  1. 사용자 정보 확인
  2. 상품 재고 확인  
  3. 재고 차감
  4. 주문 생성
  5. 결제 처리
  6. 배송 정보 등록
  
  // 중간에 실패하면 모든 작업 롤백
}
```

## ⭕액티브 레코드 패턴
액티브 레코드 패턴은 객체 지향 프로그래밍에서 데이터베이스의 테이블을 객체로 매핑하여 CRUD 작업을 수행하는 패턴이다.
- 비지니스 로직이 단순한 경우
- Active Record 라는 전용 객체를 사용하여 복잡한 자료 구조를 표현, 자료 구조 외에도 CRUD 구현,ORM 연계
- 즉 Active Record 는 데이터 접근 로직 구현
- Entity 에 약간의 비즈 로직 포함 가능하지만 대부분의 비지니스로직 및 흐름은 응용서비스의 행위에 의해 처리됨
- Anemic Domain Model (빈약한 도메인 모델)
- 본질적으로는 데이터베이스 접근을 최적화하는 Transaction Script 패턴의 유형
- 모델에 있는 로직은 사용자 입력의 유효성을 검사하는 CRUD작업과 같은 비교적 간단한 비즈로직
- 지원 하위 도메인, 일반 하위 도메인에 적합
- 비즈 로직은 단순하지만 복잡한 자료 구조인 경우

<img src="../resources/images/액티브 레코드 패턴.png" alt="액티브 레코드 패턴" style="width: 100%; height: auto;" />

### ◉ 장점
- 구현이 직관적이고 이해하기 쉬움
- 빠른 개발과 프로토타입 제작에 적합
- 단순한 CRUD 작업에 효율적
- ORM 프레임워크 지원으로 개발 생산성 향상
- 데이터와 행위가 한 곳에 모여 있어 응집도가 높음

### ◉ 단점
- 복잡한 비즈니스 로직 구현에 부적합
- 데이터베이스 스키마 변경 시 영향 범위가 큼
- 테스트가 어려움 (데이터베이스 의존성)
- 빈약한 도메인 모델이 되기 쉬움
- 대규모 시스템에서 유지보수 어려움

### ◉ 예제
``` kotlin
class Order {
    var customerId: Long = 0
    var productId: Long = 0
    var amount: Double = 0.0
    
    fun save() {
        // 데이터베이스에 저장 로직
    }
}

class CreateOrder {
    fun execute(orderDetails: OrderDetails) {
        try {
            db.startTransaction()
            
            val order = Order()
            order.customerId = orderDetails.customerId
            order.productId = orderDetails.productId
            order.amount = orderDetails.amount
            order.save()
            
            db.commit()
        } catch (e: Exception) {
            db.rollback()
            throw e
        }
    }
}
```

## ⭕도메인 모델 패턴
도메인 모델 패턴은 비즈니스 도메인을 객체로 모델링하여 복잡한 비즈니스 로직을 표현하는 패턴이다.
- 도메인 모델은 행위 + 자료구조를 통해 비지니스 로직 구현
- POJO로 구성 : 이미 본질적으로 복잡하므로 인프라, 기술적 관심사를 피해야 함
- 응용서비스에서는 대부분 업무 흐름 제어만 하며 주요 비지니스 로직은 도메인 모델에 위임하여 처리

<img src="../resources/images/도메인 모델 패턴.png" alt="도메인 모델 패턴" style="width: 100%; height: auto;" />

### ◉ 장점
- 복잡한 비즈니스 로직을 객체지향적으로 표현 가능 
- 도메인 지식이 코드에 명확히 표현되어 유지보수성 향상 
- 단위 테스트 작성이 용이함 (인프라 의존성 최소화)

### ◉ 단점
- 초기 설계 비용이 높음 (도메인 분석 및 모델링 필요)
- 단순한 CRUD 작업에는 과도한 복잡성 초래
- 개발자의 높은 객체지향 설계 역량 요구

## ⭕ 애그리거트 패턴
- 도메인 모델 패턴 적용 시 도메인 모델이 점점 복잡하고 비대해짐
- 이에 그 복잡성을 관리할 단위를 구분해 냄 (도메인 주도의 Aggregate)
- 대부분 한개의 Entity와 여러개의 VO구성

<img src="../resources/images/도메인%20주도%20설계의%20애그리거트%20패턴.png" alt="도메인 주도 설계의 애그리거트 패턴" style="width: 100%; height: auto;" />

### ◉ 장점
- 도메인 모델의 복잡성을 논리적 단위로 분할하여 관리
- 트랜잭션 일관성 경계를 명확히 정의
- 애그리거트 루트를 통한 접근으로 무결성 보장

### ◉ 단점
- 애그리거트 경계 설정이 어려워 잘못 나누면 성능 저하
- 애그리거트 간 참조 제약으로 구현 복잡도 증가
- 초기 설계 시 높은 도메인 지식과 경험 필요

### ◉ 애그리거트 패턴 구성요소 - Value Object
Value Object(VO)는 식별자가 없고 값 자체로 동등성을 판단하는 불변 객체입니다.
- 식별자: 값 자체가 중요
- 불변성: 생성 후 변경 불가
- 값 동등성: 모든 속성 값이 같으면 동일한 객체
- DTO와 헷갈리지 말 것 DTO는 프레젠테이션 계층과 도메인 계층에서 사용되는 구조체 개념

#### ✦ 예제
```kotlin
data class Money(
    val amount: BigDecimal,
    val currency: String = "KRW"
)

data class Address(
    val zipCode: String,
    val city: String,
    val street: String
)

val price = Money(BigDecimal("10000"))
val address = Address("12345", "서울시", "강남대로")
```

### ◉ 애그리거트 패턴 구성요소 - Entity
Entity는 고유한 식별자를 가지며 생명주기 동안 상태가 변할 수 있는 가변 객체입니다.
- 모든 도메인의 필수 구성요소
- 도메인의 고유 개념 표현
- 상태 변경 가능 (가변성)
- 자신의 생명주기와 행위를 가짐
- 다른 객체와 구별할 수 있는 식별자(고유 식별자)를 갖는 객체
- DB Entity와의 차이: 데이터와 함께 기능(행위)을 제공

#### ✦ 예제
```kotlin
class Product(
    val id: Long,
    var name: String,
    var price: Money
) {
    fun changePrice(newPrice: Money) {
        this.price = newPrice
    }
}

// 사용 예제
val product = Product(1L, "노트북", Money(BigDecimal("1500000")))
product.changePrice(Money(BigDecimal("1400000"))) // 상태 변경 가능

// 동등성 비교 - ID로만 판단
val product1 = Product(1L, "노트북", Money(BigDecimal("1500000")))
val product2 = Product(1L, "맥북", Money(BigDecimal("2000000")))
```

<img src="../resources/images/도메인 모델 예시.png" alt="도메인 모델 예시" style="width: 100%; height: auto;" />

### ◉ 애그리거트 패턴 구성요소 - 애그리거트
애그리거트는 도메인 모델의 복잡성을 관리하기 위해 관련된 Entity와 Value Object를 그룹화한 단위이다.
- 관련 객체를 하나로 묶은 군집
- Aggregate는 Entity, 목적은 데이터 일관성을 보호, 데이터 변경 시 Aggregate 단위로 처리
- Aggregate Root를 통해 Aggregate 내의 다른 Entity 및 VO 접근
- 데이터 변경의 단위, 트랜잭션 단위가 되는 연관된 객체 묶음

<img src="../resources/images/Aggregate.png" alt="Aggregate" style="width: 100%; height: auto;" />

#### ✦ 설계 고려사항
- 하나의 Transaction에서는 하나의 Aggregate만 수정함
- Transaction 일관성과 성공을 보장하도록 Aggregate 구성요소들을 설계해야 함
- 하나의 일을 잘 수행할 수 있도록 작게 설계해야함
- 작게 설계할 수록 성능이 좋고 확장에 용이함, 변경사항 Commit할 때 문제도 거의 발생되지 않음
- 한 Aggregate 에서 다른 Aggregate 의 참조는 식별자를 통해서만 참조해야 함
- 하나의 Transaction 내에서 여러 개의 Aggregate 이 수정되는 것을 방지할 수 있음
- 하나의 Transaction에서 여러 개의 Aggregate이 갱신되어야 하는 경우 다른 Aggregate 의 갱신은 비동기 통신을 활용해서 결과적 일관성을 맞춰야 함

##### ❓결과적 일관성
일관성을 유지시켜야 하는 데이터가 일정시간 다른 데이터와 일치 하지 않을 수도 있지만 어느 시점이 되면 결국 일치하게 된다.

<img src="../resources/images/Aggregate 식별자 참조.png" alt="Aggregate 식별자 참조" style="width: 100%; height: auto;" />

#### ✦ 특징
- 각 Aggregate은 일관성 있는 Transaction 경계를 형성함
- 즉, Transaction 제어가 DB에 Commit 될 때 한 Aggregate 내의 모든 구성요소들은 비즈니스 규칙을 따르면서 일관성 있게 처리되어야 함

#### ✦ 문제점
- 시간이 지날수록 하위의 객체의 인스턴스의 증가가 결국 엄청난 크기로 불어날 수 있음
- 따라서 하나의 일을 잘 수행할 수 있는 작은 Aggregate로 분리해야함

### ◉ 애그리거트 패턴 구성요소 - 도메인 이벤트
도메인 이벤트는 도메인 모델에서 발생한 중요한 사건을 나타내는 객체로 시스템의 상태 변화나 비즈니스 로직의 결과를 표현한다.
- 과거형으로 표시
- Aggregate의 퍼블릭 인터페이스의 일부, Aggregate는 자신의 Domain Event를 발행

##### 예제
- 주문: 주문됨, 취소됨
- 결제: 결제됨, 결제 실패됨
- 회원: 회원 가입됨, 회원 정보 수정됨

### ◉ 애그리거트 패턴 구성요소 - 도메인 서비스
특정 Entities/Value Objects에 속하지 않는 도메인 로직 또는 복수의 Aggregate 에 관련된 비지니스 로직 제공
- 어떤 계산이나 분석을 위해 다양한 시스템 구성요소의 호출을 조율

#### ✦ 특징
- 상태가 없는 객체
- 비즈니스 처리를 위해 다수의 Aggregate 이 포함되어야 하는 경우 Service 객체를 만들어서 처리함
- 여러 Aggregate의 데이터를 읽는 것이 필요한 계산 로직 구현을 도와줌

#### ✦ 예제
- 재고, 배송비 계산, 할인 정책 적용 등
<img src="../resources/images/도메인 서비스.png" alt="Aggregate 도메인 서비스" style="width: 100%; height: auto;" />

### ◉ 애그리거트 패턴 구성요소 - 레포지토리
레포지토리는 Aggregate를 영속화하고 조회하는 역할을 하는 객체로 도메인 모델과 데이터베이스 간의 매핑을 담당한다.
- 도메인 모델을 사용하기 위해서 Repository를 통해 도메인 객체를 조회 한 후 도메인 객체의 기능을 실행
- 도메인 객체(Aggregate)에 대한 생명주기, 즉 영속성 관리 (등록, 조회, 수정, 삭제 시 Aggregate의 일관성 유지)
- Spring Data JPA의 Repository인터페이스

### ◉ 애그리거트 패턴 구성요소 - 팩토리
복잡한 Entity나 Aggregate를 생성하는 로직을 캡슐화하여 객체 생성의 복잡성을 줄이는 역할을 한다.

#### ✦ 특징
- 객체의 생성 과정과 관련된 지식이 정리된 객체로 특정 정보를 Factory에 보내면 결과로 Entity 또는 Aggregate 을 생성함
- 복잡한 생성 로직을 숨겨 개발자들이 내부의 복잡함에 신경 쓰지 않아도 됨

### ◉ 애그리거트 패턴 구성요소 - 응용 서비스
Repository에서 데이터를 조회하고 도메인 로직을 호출한 후 결과를 저장하는 과정을 하나의 트랜잭션으로 묶어서 처리하는 서비스다.
- 도메인 모델에 속하지 않음.
- Repository 와 밀접한 연관
- 트랜잭션 처리
- 응용계층
- Aggregate 를 저장하는 메소드, Aggregate Root 식별자로 Aggregate를 조회하는 Method 제공

#### ✦ 예제
- 주문 서비스
- 결제 서비스
- 회원 서비스

## ⭕이벤트 소싱 모델
이벤트 소싱 모델은 도메인 이벤트를 중심으로 시스템의 상태를 관리하는 패턴이다. 모든 상태 변화는 이벤트로 기록되며 현재 상태는 이벤트의 시퀀스를 통해 재구성된다.
- 상태 변화 이벤트만 저장 (기존 방식은 상태 기반, 상태를 DB에 저장)
- 현재 상태는 이벤트들을 순서대로 재생해서 복원

### ◉ 특징
- 불변성: 이벤트는 변경되지 않으며 모든 상태 변화는 이벤트로 기록됨
- 재현 가능성: 이벤트를 재생하여 시스템의 상태를 언제든지 재구성할 수 있음
- 추적: 이벤트 로그를 통해 시스템의 모든 상태 변화 이력을 추적할 수 있음

### ◉ 예제
- 주문 생성 이벤트, 결제 완료 이벤트, 배송 시작 이벤트 등

##### ❓어느 시점에 어떤 패턴을 사용 해야 하는가?
 🟢 간단한 CRUD 중심 (복잡도: 낮음) - 추천 패턴: 트랜잭션 스크립트 패턴
- 언제: 게시판, 사용자 관리, 설정 관리
- 특징: 빠른 개발, 직관적 구조
- 예시: 블로그, 간단한 관리자 페이지

🟡 중간 복잡도 비즈니스 로직 - 추천 패턴: 액티브 레코드 패턴
- 언제: ORM 활용, 적당한 비즈니스 규칙
- 특징: Rails, Django 스타일
- 예시: 소규모 쇼핑몰, 예약 시스템

🟠 복잡한 비즈니스 도메인 (복잡도: 높음) - 추천 패턴: 도메인 모델 패턴
- 언제: 복잡한 규칙, 여러 객체 간 상호작용
- 특징: 객체지향 설계 원칙 적용
- 예시: 은행 시스템, 대형 이커머스

🔴 매우 복잡한 엔터프라이즈 (복잡도: 매우 높음) - 추천 패턴: 애그리거트 패턴
- 언제: 여러 팀, 큰 규모, 복잡한 도메인
- 특징: DDD 전면 적용, 바운디드 컨텍스트
- 예시: 대기업 ERP, 금융 플랫폼

⚫ 특수 요구사항 (감사추적/분석 중요) - 추천 패턴: 이벤트 소싱
- 언제: 완벽한 이력 관리, 복잡한 분석
- 특징: 모든 변화 기록, 시간 여행 가능
- 예시: 금융 거래, 의료 기록

